import { write, exitWithError } from 'bash-node'
import { validateJoi, parseYamlFile } from './helpers.js'
import { MySQL, Postgres, SQLite, id, notNull, randomId, schema, unique } from './yaml_schema.js'

export function generate(filePath, options) {
  const sqlVarient = parseInt(options.varient)
  if (!sqlVarient || ![Postgres, MySQL, SQLite].includes(sqlVarient)) {
    exitWithError('sql varient not specified or incorrect')
  }

  const multipleSchema = parseYamlFile(filePath)
  const isValid = validateJoi(multipleSchema, schema)
  if (!isValid) exitWithError(`error in file: ${filePath}`)
  let sqlStatement = ''
  for (const schema of multipleSchema) {
    sqlStatement += genrateSqlSchema(schema, sqlVarient) + '\n'
  }
  if (options.output) {
    var outputFilePath = filePath.replace('yaml', 'sql')
    write(outputFilePath, sqlStatement)
  } else {
    return sqlStatement
  }
}

const intTypeMapping = {
  int16: 'SMALLINT',
  int32: 'INTEGER',
  int64: 'BIGINT',
}

function genrateSqlSchema(tableDetails, varient) {
  // Filter primary & non primary columns
  const primaryColumns = []
  const otherColumns = []
  for (const column of tableDetails.properties) {
    if (column?.tags?.includes(id) || column?.tags?.includes(randomId)) {
      primaryColumns.push(column)
    } else otherColumns.push(column)
  }

  // check atleast one primary key exits, else warn
  if (primaryColumns.length == 0) {
    console.warn(`warning: no primary key found in ${tableDetails.name}`)
  }

  // Check if it is a composite key (i.e more than one keys form a primary key)
  const isComposite = primaryColumns.length > 1

  // lines contains lines inside the "CREATE TABLE name ( ** );" block
  const lines = [
    ...addPrimaryKey(primaryColumns, isComposite, varient),
    ...genrateColumns(otherColumns, varient),
    isComposite ? addPrimaryConstraints(primaryColumns) : '',
  ]

  return `CREATE TABLE ${tableDetails.name} (
\t${lines.filter((l) => l.trim() != '').join(',\n\t')}
)${addTableInfo(primaryColumns, varient)};\n`
}

function genrateColumns(columnsDetails, varient) {
  const columns = []
  for (const column of columnsDetails) {
    columns.push(`${column._name} ${getDatatype(column, varient)} ${getConstraints(column, varient)}`)
  }
  return columns
}

function addPrimaryKey(columnsDetails, isComposite, varient) {
  const columns = []
  for (const column of columnsDetails) {
    if (varient == Postgres && !isComposite && !column.refrences) {
      const startValue = column.tags.includes(randomId) ? primaryKeyStartVal() : 1
      const columnDefination = `${column._name} ${getDatatype(column, varient)}`
      columns.push(
        `${columnDefination} PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH ${startValue} INCREMENT BY 1)`
      )
    } else if (varient == MySQL && !isComposite && !column.refrences) {
      columns.push(`${column._name} ${getDatatype(column, varient)} PRIMARY KEY AUTO_INCREMENT`)
    } else {
      columns.push(
        `${column._name} ${getDatatype(column, varient)} ${isComposite ? '' : 'PRIMARY KEY'} ${getConstraints(
          column,
          varient
        )} `
      )
    }
  }
  return columns
}

function addPrimaryConstraints(columnsDetails) {
  return `PRIMARY KEY (${columnsDetails.map((e) => e._name).join(', ')})`
}

// Get data type of the column
function getDatatype(columnDetails, varient) {
  let output = ''
  const type = columnDetails.type

  if (type.startsWith('int')) {
    if (varient == SQLite) output = 'INTEGER'
    else output = intTypeMapping[type]
  } else if (type == 'string') {
    if (columnDetails.max_length) {
      if (varient == SQLite || varient == Postgres) {
        output = `TEXT CHECK (LENGTH(${columnDetails._name}) <= ${columnDetails.max_length})`
      } else output = `VARCHAR(${columnDetails.max_length})`
    } else {
      output = `TEXT`
    }
  } else if (type == 'json') {
    if (varient == SQLite || varient == Postgres) output = 'JSONB'
    else output = 'JSON'
  } else if (type == 'bool') {
    output = 'BOOLEAN'
  } else if (type == 'binary') {
    if (varient == SQLite) output = 'BLOB'
    else if (varient == MySQL) output = 'VARBINARY(255)'
    else output = 'BYTEA'
  } else if (type == 'enum') {
    if (varient == SQLite) output = 'INTEGER'
    else output = 'SMALLINT'
  } else if (type == 'date') {
    output = 'INTEGER'
  } else if (type == 'time') {
    if (varient == SQLite) output = 'INTEGER'
    else output = 'BIGINT'
  }

  return output
}

// Get constraints of the column like UNIQUE, NOT NULL, REFRENCES etc.
function getConstraints(columnDetails, varient) {
  let output = ''

  if (columnDetails.tags) {
    for (const tag of columnDetails.tags) {
      if (tag == unique) output += ' UNIQUE'
      if (tag == notNull) output += ' NOT NULL'
    }
  }

  if (columnDetails.refrences) {
    const [table, column_name] = columnDetails.refrences.split('.')
    output += ` REFERENCES ${table} (${column_name})`
  }

  if (columnDetails.type == 'enum') {
    const values = columnDetails.values
    if (!values) {
      exitWithError(`values for the enum ${columnDetails._name} not found`)
    }
    const columnName = columnDetails._name
    output += ` CHECK (${columnName} > 0 AND ${columnName} < ${values.length + 1})`
  }

  return output
}

// currently used by MySQL to add auto increment start value
function addTableInfo(primaryColumns, varient) {
  // returns if not MySQL varient or composite primary key or no primary key or primary key is refrencing another table
  if (varient != MySQL) return ''
  if (primaryColumns.length > 1) return ''
  if (primaryColumns.length == 0) return ''
  if (primaryColumns[0].refrences) return ''

  // Add auto increment values for MySQL
  if (primaryColumns[0].tags.includes(randomId)) return ` AUTO_INCREMENT = ${primaryKeyStartVal()}`
  else return ' AUTO_INCREMENT = 1'
}

// only used for tag with random_id to get a random statting primary id
function primaryKeyStartVal() {
  return 1001
}
